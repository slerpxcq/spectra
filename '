#include <iostream>
#include <cassert>
#include <chrono>
#include <algorithm>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <complex>
#include <queue>


// GL
#include <glad/glad.h>
#include <GLFW/glfw3.h>

// ImGui
#include <imgui.h>
#include <backends/imgui_impl_glfw.h>
#include <backends/imgui_impl_opengl3.h>
#include <implot.h>

// pffft
#include <pffft.hpp>

// spline
//#include <spline.h>

// miniaudio
#define MINIAUDIO_IMPLEMENTATION
#include <miniaudio.h>
#undef max
#undef min

//#define SP_USE_DOUBLE_PRECISION

#ifdef SP_USE_DOUBLE_PRECISION
#define SP_FLOAT  double
#else 
#define SP_FLOAT float
#endif

#define SP_ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))

#ifndef SP_USE_DOUBLE_PRECISION
#define SP_LOG2(x) std::log2f(x)
#define SP_LOG(x) std::logf(x)
#define SP_ABS(x) std::fabsf(x)
#define SP_EXP(x) std::expf(x)
#define SP_POW(x,y) std::powf(x,y)
#else
#define SP_LOG2(x) std::log2(x)
#define SP_LOG(x) std::log(x)
#define SP_ABS(x) std::fabs(x)
#define SP_EXP(x) std::exp(x)
#define SP_POW(x,y) std::pow(x,y)
#endif

#define SP_TIME_NOW() std::chrono::high_resolution_clock::now()
#define SP_TIMEPOINT decltype(SP_TIME_NOW())
#define SP_TIME_DELTA(x) (std::chrono::duration_cast<std::chrono::microseconds>(SP_TIME_NOW() - (x)).count() * 1e-6f)

static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)
{
    return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y);
}

static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)
{
    return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y);
}

static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)
{
    return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y);
}

static constexpr uint32_t CHANNEL_COUNT = 2;
static constexpr uint32_t SAMPLE_COUNT = 8192;
static constexpr uint32_t FFT_RESULT_SIZE = SAMPLE_COUNT / 2;
static constexpr uint32_t LEFT_CH = 0;
static constexpr uint32_t RIGHT_CH = 1;

// Ring buffer
static constexpr uint32_t BUFFER_CAPACITY = 2 * SAMPLE_COUNT;
static SP_FLOAT sampleBuffer[CHANNEL_COUNT][BUFFER_CAPACITY];
static std::mutex sampleBufferMutex;
static uint32_t writePtr;
static uint32_t readPtr;

static std::mutex samplesReadyMutex;
static std::condition_variable samplesReadyCondition;

// [channel][values]
static SP_FLOAT drawBuffer[CHANNEL_COUNT][SAMPLE_COUNT / 2];
static std::mutex drawBufferMutex;
static SP_FLOAT thresholds[CHANNEL_COUNT][FFT_RESULT_SIZE];
static SP_FLOAT heights[CHANNEL_COUNT][FFT_RESULT_SIZE];
//static ImVec2 points[CHANNEL_COUNT][FFT_RESULT_SIZE];

static float resultOffset = 0.5f;
static float resultScale = 0.03f;
static float fallSpeed = 0.1f;

void SamplesReadyCallback(ma_device* pDevice, void* pOutput, const void* pInput, ma_uint32 frameCount)
{
    (void)pOutput;

    SP_FLOAT* inputs = (SP_FLOAT*)pInput;
    {
        std::lock_guard l(sampleBufferMutex);
		for (uint32_t i = 0; i < frameCount; ++i, ++writePtr) {
			writePtr %= BUFFER_CAPACITY;
			sampleBuffer[LEFT_CH][writePtr] = inputs[2 * i];
			sampleBuffer[RIGHT_CH][writePtr] = inputs[2 * i + 1];
		}
		readPtr = ((int64_t)writePtr - SAMPLE_COUNT) % BUFFER_CAPACITY;
    }
	samplesReadyCondition.notify_all();
}

void GenBlackmanHarrisWindow(SP_FLOAT* dst)
{
    static constexpr SP_FLOAT a0 = 0.355768f;
    static constexpr SP_FLOAT a1 = 0.487396f;
    static constexpr SP_FLOAT a2 = 0.144232f;
    static constexpr SP_FLOAT a3 = 0.012604f;
    static constexpr SP_FLOAT PI = 3.14159265359;
    static SP_FLOAT N = SAMPLE_COUNT;

    for (uint32_t i = 0; i < N; ++i) {
        dst[i] = a0 - a1 * std::cosf(2 * PI * i / N) + a2 * std::cosf(4 * PI * i / N)
            - a3 * std::cosf(6 * PI * i / N);
    }
}

SP_FLOAT FastMag(const std::complex<SP_FLOAT>& c)
{
	float absRe = SP_ABS(c.real());
    float absIm = SP_ABS(c.imag());
	float max = std::max(absRe, absIm);
	float min = std::min(absRe, absIm);
	return max + 3 * min / 8;
}

void FFTWorker()
{
	static pffft::Fft<SP_FLOAT> fftInstance(SAMPLE_COUNT);
    static SP_FLOAT window[SAMPLE_COUNT];
    auto fftIn = fftInstance.valueVector();
    auto fftOut = fftInstance.spectrumVector();

    static SP_FLOAT mag[CHANNEL_COUNT][FFT_RESULT_SIZE];

    GenBlackmanHarrisWindow(window);

    while (true) {
        // Wait for samples
        std::unique_lock lock(samplesReadyMutex);
        samplesReadyCondition.wait(lock);

        for (uint32_t channel = 0; channel < CHANNEL_COUNT; ++channel) {
            {
                std::lock_guard lock(sampleBufferMutex);
				for (uint32_t i = 0, rdptr = readPtr; i < SAMPLE_COUNT; ++i, ++rdptr) {
					rdptr %= BUFFER_CAPACITY;
					fftIn[i] = sampleBuffer[channel][rdptr] * window[i];
				}
            }

			fftInstance.forward(fftIn, fftOut);

			{
				std::lock_guard lock(drawBufferMutex);
				for (uint32_t i = 0; i < FFT_RESULT_SIZE; ++i) {
                    SP_FLOAT mag = FastMag(fftOut[i]);
                    heights[channel][i] = std::max(mag, thresholds[channel][i]);
					thresholds[channel][i] = std::max(mag, thresholds[channel][i]);
				}
            }
        }
    }
}

int main(int argc, char** argv) 
{
    /******************************* FFT init *******************************/ 
    /******************************* miniaudio *******************************/ 
    ma_result result;
    ma_device_config deviceConfig;
    ma_device device;

    deviceConfig = ma_device_config_init(ma_device_type_capture);
    deviceConfig.capture.format   = ma_format_f32;
    deviceConfig.capture.channels = CHANNEL_COUNT;
    deviceConfig.sampleRate       = 44100;
    deviceConfig.dataCallback     = SamplesReadyCallback;

    result = ma_device_init(NULL, &deviceConfig, &device);
    assert(result == MA_SUCCESS);

    /******************************* glfw *******************************/ 

    GLFWwindow* window = nullptr;

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    if (!glfwInit())
        return -1;

    window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
    if (!window) {
        glfwTerminate();
        return -1;
    }

    glfwMakeContextCurrent(window);
    glfwSwapInterval(1);
    int version = gladLoadGL();
    assert(version);

    /******************************* imgui *******************************/ 
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImPlot::CreateContext();
    ImGuiIO& io = ImGui::GetIO(); 
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls

    ImGui::StyleColorsDark();
    ImGui_ImplGlfw_InitForOpenGL(window, true);
    ImGui_ImplOpenGL3_Init("#version 430");

    result = ma_device_start(&device);
    assert(result == MA_SUCCESS);

    auto fftThread = std::thread(FFTWorker);
    fftThread.detach();

    static SP_TIMEPOINT lastTime = SP_TIME_NOW();
    static constexpr float TIME_STEP = 1.f / 60;

	static SP_FLOAT xs[FFT_RESULT_SIZE];
    for (uint32_t i = 0; i < FFT_RESULT_SIZE; ++i)
        xs[i] = i;

    while (!glfwWindowShouldClose(window)) {
        // Rendering
        glfwPollEvents();

        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();

        //ImGui::Begin("Control");
        //ImGui::SliderFloat("Result offset", &resultOffset, 0.0f, 1.0f);
        //ImGui::SliderFloat("Result scale", &resultScale, 0.01f, 0.05f);
        //ImGui::SliderFloat("Fall speed", &fallSpeed, 0.01f, 0.2f);
        //ImGui::End();

        ImGuiIO& io = ImGui::GetIO();
        ImGui::SetNextWindowPos(ImVec2(0, 0));
        ImGui::SetNextWindowSize(io.DisplaySize);
        ImGui::Begin("Draw", nullptr, ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar);

        ImDrawList* drawList = ImGui::GetWindowDrawList();
        ImVec2 min = ImGui::GetWindowContentRegionMin();
        ImVec2 max = ImGui::GetWindowContentRegionMax();
        ImVec2 pos = ImGui::GetWindowPos();
        ImVec2 origin = pos + min;
        ImVec2 size = max - min;

        static constexpr uint32_t colors[2] = {
            IM_COL32(255, 0, 0, 128),
            IM_COL32(0, 0, 255, 128)
        };

        float deltaTime = SP_TIME_DELTA(lastTime);
		lastTime = SP_TIME_NOW();

        {
			std::lock_guard lock(drawBufferMutex);
			static float acc;
			acc += deltaTime;
			while (acc >= TIME_STEP) {
				for (uint32_t channel = 0; channel < CHANNEL_COUNT; ++channel) {
					for (uint32_t i = 0; i < FFT_RESULT_SIZE; ++i) {
						thresholds[channel][i] /= std::max(SP_EXP(thresholds[channel][i]), SP_FLOAT(1.01));
					}
				}
				acc -= TIME_STEP;
			}

            // spline
            //std::vector<double> xv(xs, xs + SP_ARRAY_SIZE(xs));
            //std::vector<std::vector<double>> yvs;
            //for (uint32_t i = 0; i < CHANNEL_COUNT; ++i) 
            //    yvs.push_back(std::vector<double>(heights[i], heights[i] + SP_ARRAY_SIZE(heights[i])));
            //
            //std::vector<tk::spline> splines;
            //for (uint32_t i = 0; i < CHANNEL_COUNT; ++i)
            //    splines.emplace_back(xv, yvs[i]);
               
            if (ImPlot::BeginPlot("FFT", size, ImPlotFlags_CanvasOnly) {
                ImPlot::SetupAxisScale(ImAxis_X1, ImPlotScale_Log10);
                ImPlot::SetupAxisScale(ImAxis_Y1, ImPlotScale_Log10);
                ImPlot::SetupAxesLimits(1, FFT_RESULT_SIZE, 0.001, 100, ImPlotCond_Always);
                //ImPlot::SetupAxesLimits(1, FFT_RESULT_SIZE, -1, 20, ImPlotCond_Always);
                ImPlot::PlotShaded("L", xs, heights[LEFT_CH], FFT_RESULT_SIZE);
                ImPlot::PlotShaded("R", xs, heights[RIGHT_CH], FFT_RESULT_SIZE);
                ImPlot::EndPlot();
            }
        }

        ImGui::End();
        ImGui::Render();
        int display_w, display_h;
        glfwGetFramebufferSize(window, &display_w, &display_h);
        glViewport(0, 0, display_w, display_h);
        glClearColor(0.1, 0.1, 0.1, 1.0);
        glClear(GL_COLOR_BUFFER_BIT);
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

        glfwSwapBuffers(window);
    }

    glfwTerminate();

    ma_device_uninit(&device);

    return 0;
}
